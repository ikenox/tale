---
layout: post
title: CleanArchitectureとは
---

# CleanArchitecture

## ドメイン駆動設計の入門書籍を読んだ

ドメイン駆動設計の思想と原則を紹介した書籍が、80ページ程度のPDFとして無償で公開されている。

[Domain Driven Design（ドメイン駆動設計） Quickly 日本語版](https://www.infoq.com/jp/minibooks/domain-driven-design-quickly)

> この本は、短くすばやく読める要約とDDの原則の紹介です。新しい概念を紹介する事はありません。 DDDとは何なのかについて正確な要約を試みたのがこの本です。

この書籍は、2007年に出版された[Domain-Driven Design Quickly](http://www.lulu.com/shop/floyd-marinescu-and-abel-avram/domain-driven-design-quickly/paperback/product-2117794.html)の和訳版とのこと。タイトルからも分かる通り、ドメイン駆動設計について最低限の基礎を学ぶことができる。10年近く前の書籍ではあるが、ドメイン駆動設計の基礎を学ぶ分には内容も量も良い感じだと思い、全て読みこんでみた。  
80ページ程度なので読んでる途中で挫折しづらいし、それでいてドメイン駆動設計のエッセンスについてはきちんと理解することができる一冊になっていると思う。このような書籍が無償で公開されているのはありがたい。

## アンチパターンを考える

そこで今回、上記書籍を読み、そこに書いてあった設計原則について、**「その原則を守らなかった場合、どういった時にヤバいことになるのか」というアンチパターンをひたすら考えてみる** ことにした。
基本は以下を構成単位としてひたすら羅列していきます。

```
- アンチパターン例
- ドメイン駆動設計のどの原則に反しているか
- そのアンチパターンだとどういった時に困るのか
  - どういうコードが増えるか
```

## なぜアンチパターンか

この書籍に限らず、自分がこういった設計手法関連の書籍を読んだ時にありがちなこととして、**この原則を守った方が確かにきれいな設計になりそう」なことは間違いなく理解できる**けど、**「この原則を守らなかった時、具体的にはどのようなヤバいことが起きるのか？」というのをすぐには想像できない**ことが多く、本書籍についても同様の状態となってしまった。(Evans本を途中で挫折してしまうのもそういう難しさがあるからではないか？)  
設計原則やその所以についての説明というのはどうしても抽象的な話になってしまうがために、一定仕方ないのかなとも思っている。

思い返してみると、普段の仕事の開発でも、**「この設計だと○○の原則を守ってなくてなんだかヤバい匂いがするが、具体的にどういった時にマズいことになりそうなのかうまく言語化できない」** という体験がしばしばある。「○○の原則を守ってないのでダメ！」というだけだといまいち説得力が足りないので、こういった時すぐに具体例が出せると、納得感を伴った上で設計方針の軌道修正ができそうである。

webサービスの開発現場のようにスピード感が求められる場合においては、ドメイン駆動設計のような設計指針を厳守するというのは難しく、しばしば実装コストとトレードオフになる。  
設計の綺麗さと実装コストとのトレードオフを考える時、「これだとこういう変更が入った時にヤバい」という言語化ができると、自分の持っている危機感をよりハッキリとした輪郭でチームメンバーと共有できる。  
そうすると、「そういう変更が入る」ことがどれくらい実際に起こりうることなのかや、そのヤバさの程度がどれくらいなのかを加味した上で、設計とスピードのどちらを優先するかについて適切な判断が下せるようになるのではないか。

# ドメイン駆動設計の原則と、そのアンチパターン集

## ドメインモデルに

### 共通概念の属性群は切り出すべき

- userモデルが直接市町村、県、番地を持つよりは、addressモデルに切り出して一括管理した方がいい
    - 「住所データを消去」のような操作の影響範囲が明確となる
        - ふやしたときの影響範囲は？？

### バリューオブジェクトは変更されないべき

- 変更されると？

### ステータスコードの扱い

### before


```java
# ==================
# HogeController
# ==================

$status_code = HogeModel->get_status_code($user_id);

# 審査OKの場合
if($status_code == 0 || $status_code == 9){
    # do_something
}

```

- 問題点
    - コントローラーがstatus_code（非ユビキタス言語、非ドメイン知識）について知っている
    - ステータスコード増えた時に収集つかなくなる
        - ステータスコードで分岐してる全てのControllerを直して回ることに

- modelから引っ張ってきたデータに対して(boolean除き)if文で分岐してたら要注意
- 本質的にcontrollerが知りたい情報以外についてハンドリングしてたらなんかおかしい
- そもそもステータスを列挙してORしてる時点でなんかおかしいかも
異なるステータスが同一の意味を持っていることに他ならない、分離が足りていない
- きちんと分離できていると

## そもそもステータスって？

- ステータスの意味が曖昧なのでみんな好きになんでもステータス増やしてしまう
    - 「CS審査結果」「車検証登録状態」「」とかに分離して持っとくべき


### after

```
# ==================
# HogeController
# ==================

$is_accepted = HogeModel->is_accepted_user($user_id);

if($is_accepted){
    # do_something
}

# ==================
# HogeModel
# ==================

sub is_accepted_user($user_id) {
    $status_code = get_status_code($user_id);
    return $status_code == 0 || $status_code == 9;
}
```

- Controllerからはユビキタス言語の関数を呼び出す
- ステータスコードの判定ロジックが自然と集約される

## model or usecase?

entity or repositoryの関数が出現するようならusecase?

## master, slaveの扱い

# client

## グローバル変数の弊害

- 「この画面(関数)にこの引数で入ってきた場合はこの状態」というのが担保できなくなるため、テストケースが膨大になる
    - ユーザーがどういった画面遷移からその画面にたどりついたか、などによってグローバル変数の状態が変わるため、無限に考慮パターンが増える

# おわりに

## アンチパターンを考えるということ
